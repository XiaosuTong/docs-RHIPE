### Read and Divide by County ###
Our division method for the housing data will be to divide by county,
so there will 2883 subsets. Each subset will be a `data.frame` object with 4
column variables: `date`, `units`, `listing`, and `selling`.
`FIPS`, `state`, and `county` are not column variables because each has only one
value for each county; their values are added on the `data.frame` as
attributes.

The first step is to read each line of the file 'house.txt' into R. By
convention, `RHIPE` takes each line of a text file to be a key-value pair.
The line number is the key. The value is the data for the line, in our case
the 7 observations of the 7 variables of the data for one month and one county.
Also, when a line is read into R, each observation becomes of type character.

Each line is read as part of Map R code written by the user. The Map input
key-value pairs are the above line key-value pairs. Each line also has a Map
output key-value pair. The key identifies the county. `FIPS` could have been
enough to do this, but it is specified as a character vector with three
elements: the 3-vector values of `FIPS`, `state`, and `county`.
This is done so that
later all three can be added to the subset `data.frame`.
The Map output value for each line is the observations of `date`, `units`,
`listing`, and `selling` from the line.

The Map outputs are the inputs for the Reduce R code written by the user.
Reduce assembles these into groups by key, which means by  county. It then
creates the subset `data.frame` object for each county. Each row is the value
of one Reduce input key-value pair: observations of `date`, `units`, 
`listing`, and `selling`. `FIPS`, `state`, and `county` are added to the
`data.frame` as attributes. Finally, Reduce writes
each subset `data.frame` object to a directory in the HDFS specified by the
user.  The subsets are written as Reduce output key-value pairs.
The output keys are the the values of `FIPS`. The output values are the county
`data.frame` objects.

#### Master and Commander: rhwatch() ####

We begin with the `RHIPE` R function `rhwatch()`. It
runs the R code you write to specify
Map and Reduce operations, takes your specification of input and
output files, and manages key-value pairs for you.

The code for the county division is
```{r eval=FALSE, tidy=FALSE}
mr3 <- rhwatch(
  map      = map3,
  reduce   = reduce3,
  input    = rhfmt("/myloginname/housing/housing.txt", type = "text"),
  output   = rhfmt("/myloginname/housing/byCounty", type = "sequence"),
  readback = FALSE,
  mapred   = list(
    mapred.reduce.tasks = 10
  ),
)
```

Arguments `map` and `reduce` take your Map and Reduce R code.
`input` specifies the input text file in the HDFS that we put there earlier
using `rhput()`. `output` specifies the file name into which final outputs of
the Reduce operation are written. Note that `rhwatch` creates this file.

In our division by county here, the Reduce outputs are the 2,883 county
`data.frame` R objects. They are written as key-value pairs
to the output directory housing created earlier.
The keys and values are just those of the Reduce output:
`FIPS` and the
county `dataframe` objects. The key-value pair object is a list with one
element per key-value pair. The element is a list too, with two elements; the
first is the `FIPS` key, and the second is the county `data.frame`.

A very important point here is that these key-value pairs are an R object.
So they can be written to the  R global environment of the R session.
This can be done by the argument `readback`. If `TRUE`, the list is also
written to the R global environment of the R
session. If `FALSE`, it is not.
If later, this is wanted, then it can be done
using the RHIPE R function `rhread`.
```{r eval=FALSE, tidy=FALSE}
countySubsets <- rhread("/myloginname/housing/byCounty")
```
Suppose, however, that you just want to look over the first 10 elements of
`byCounty` to make sure all is well. This can be done by
```{r eval=FALSE, tidy=FALSE}
countySubsets <- rhread("/myloginname/housing/byCounty", max = 10)
```
```
Read 10 objects(31.39 KB) in 0.04 seconds
```
Just the first 10 elements are read

Then you can look at the list of length 10 in various was such as

```{r eval=FALSE, tidy=FALSE}
keys <- unlist(lapply(countySubsets, "[[", 1))
keys
```
```
 [1] "01013" "01031" "01059" "01077" "01095" "01103" "01121" "04001" "05019" "05037"
```

```{r eval=FALSE, tidy=FALSE}
attributes(countySubsets[[1]][[2]])
```
```
$names
[1] "date"             "units"            "list"             "selling"

$row.names
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
[33] 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 
[65] 65 66

$state
[1] "AL"

$FIPS
[1] "01013"

$county
[1] "Butler"

$class
[1] "data.frame"
```

#### Map R Code ####
The Map R code written for the county division is

```{r eval =FALSE, tidy=FALSE}
map3 <- expression({
  lapply(seq_along(map.keys), function(r) {
    line = strsplit(map.values[[r]], ",")[[1]]
    outputkey <- line[1:3]
    outputvalue <- data.frame(
      date = as.numeric(line[4]),
      units =  as.numeric(line[5]),
      list = as.numeric(line[6]),
      selling = as.numeric(line[7]),
      stringsAsFactors = FALSE
    )
  rhcollect(outputkey, outputvalue)
  })
})
```

This code is really a `for loop`, but is done by `lapply()` because it is in
general faster. But we could have used `for r in 1:length(map.keys)`.
The loop proceeds through the input keys, which are the line numbers, as
specified by the first argument of `lapply`. The R `list` object `map.keys`
contains them; it is created by `rhwatch()`.  The
second argument of the above `lapply` defines the Map function with the
argument `r`, an index for the Map keys that goes from 1 to `length(map.keys)`.

`map.values` is also a `list` object created by `rhwatch()`.
`map.values[[r]]` is the value for key `map.keys[[r]]`.
The result of `line` in the `lapply` function is the input values, a
text string.  The function `strsplit()` splits the string data
into the individual observations of the text line,
and creates a `list` of length one whose element is a vector of length 7 that
becomes `line`. `outputkey` is the FIPS
observation for the file line. `outputvalue` is a `data.frame` with one row
and 6 columns of the values of variables for the text line that omits the state.

The RHIPE function `rhcollect()` forms a key-value pair for each line.

#### Reduce R Code ####

```{r eval=FALSE, tidy=FALSE}
reduce3 <- expression(
  pre = {
    reduceoutputvalue <- data.frame()
  },
  reduce = {
    reduceoutputvalue <- rbind(reduceoutputvalue, do.call(rbind, reduce.values))
  },
  post = {
    reduceoutputkey <- reduce.key[1]
    attr(reduceoutputvalue, "location") <- reduce.key[1:3]
    names(attr(reduceoutputvalue, "location")) <- c("FIPS","county","state")
    rhcollect(reduceoutputkey, reduceoutputvalue)
  }
)
```

`reduce.key` is a character vector with length three in this example, which is the 
input key of the reduce step. `reduce.values` is a `list` object. Each element is 
the Reduce input values for one Reduce input key. Same as in the Map, `reduce.key` 
and `reduce.values` are created by `rhwatch()` when the job is processing.

Reduce groups the Map output key-value pairs by Map output key, the vector with FIPS, 
county, and state.  The current group's key is available in the object `reduce.key`, and 
values associated with that key are elements of the list object named `reduce.values`. Recall 
that the `reduce.key` will be a character vector with length three, and they are FIPS, 
county name, and state name in this order. And each element of `reduce.values` list 
is a one-row `data.frame`. The reduce expression has three parts: `pre`, 
which is executed once first; `reduce`, which is executed repeatedly until all 
values associated with the current key have been processed; and `post`, 
which is executed once at the end.  

In the reduce expression above, our goal is to combine all observations
associated with one particular county into a single `data.frame`.  In `pre`,
we initialize an empty `data.frame` named `reduceoutputvalue`.  In `reduce`,
we first use `do.call` with `rbind` to combine observations associated with one
particular county. Recall that `reduce` will be executed repeatedly. That means
`reduce.values` does not include all observations associated with one county at one
time. So we need another `rbind` to recursively combined the results from `do.call` with 
`reduceoutputvalue` to make sure we collect all values associated with one county.
In `post`, we add three attribute to the `data.frame` containing the FIPS information, 
county name, and state name and emit the final key-value pair. The output key is the first 
element of `reduce.key`, which is the FIPS, and the value is the `data.frame` with all 
observations belonging to that county with three attributes we created.
These final key-value pairs are written to HDFS, and will persist for subsequent analyses.

By removing the FIPS, county, and state columns from the `data.frame` and
storing them as attributes, we've eliminated redundant information in each
`data frame`. Working with massive data sets, we want our data to take up the
least possible space on disk in order to save read/write time. Also we only
keep the first element in `reduce.key` which is the `FIPS` as the key in output
key/value pairs.

