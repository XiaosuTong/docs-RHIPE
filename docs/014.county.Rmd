### Read and Divide by County ###
We will now divide the housing data into subsets by county, so
there will 2883 subsets. Each subset will be a `data.frame` object with 4
column variables: `date`, `units`, `listing`, and `selling`.
`FIPS`, `state`, `county` are not column variables because each has only one
value for each county; their values are added on the `data.frame` as
attributes.

The first step is to read each line of the file 'house.txt' into R. By
convention, `RHIPE` takes each line of a text file to be a key-value pair.
The line number is the key. The value is the data for the line: the 7
observations of the 7 variables of the data for one month and one county.
Also, when a line is read into R, each observation becomes of type character.

Each line is read as part of Map R code written by the user.
The output of Map is a key-value pair for each line.
The Map output key identifies the county; it is specified as values
of `FIPS`, `state`, `county` so all three value are present,
but either `FIPS` or `county` would have been enough to identify the county.
The Map output value for each
line is the observations of `date`, `units`, `listing`, and `selling` from the
line.

The Map outputs are the inputs for the Reduce R code written by the user.
Reduce assembles the line outputs into groups by count, and creates the
subset `data.frame' object for each state, and then writes every object to a
directory in the HDFS specfied by the user. They are written as key-value
pairs. Each pair consists of a key that identifies the county and a
`data.frame`, subset object for the county.

#### Master and Commander: rhwatch() ####

We begin with the `RHIPE` R function `rhwatch()` that runs your R code
specifying Map and Reduce operations, allows you to certain specify input and
output files, and as we will see, manages key-value pairs for you.

The code for the county division is
```{r eval=FALSE, tidy=FALSE}
mr3 <- rhwatch(
  map      = map3,
  reduce   = reduce3,
  input    = rhfmt("/myloginnamehousing/housing.txt", type = "text"),
  output   = rhfmt("/myloginname/housing/housing/byCounty", type = "sequence"),
  readback = FALSE,
  mapred   = list(
    mapred.reduce.tasks = 10
  )
)
```

Arguments `map` and `reduce` take your Map and Reduce R code.
`input` specifies the input text file in the HDFS that we put there earlier
using `rhput()`. `output` specifies the directory where the final outputs of
the Reduce operation are written. In our division by county here,
the Reduce outputs are the 49 county `data.frame` R objects.
They are placed
there as key-value pairs, each pair consisting of a county key it
`data.frame`. `readback = FALSE` tells `RHIPE` not to write the Reduce output
to the global environment of your R session on the R session server.
Please see the detailed R documentation about `mapred.reduce.tasks`,
and about other arguments for `rhwatch` not used above.

After the job completes successfully, we'll read the results from HDFS into our interactive R 
session as we did before.  This time, let's use the `max` argument to `rhread`, which specifies 
how many key-value pairs to read. The default value is -1, which means read in all key-value pairs.

```{r eval=FALSE, tidy=FALSE}
countySubsets <- rhread("/ln/tongx/housing/byCounty", max = 10)
```

Read 10 objects(31.39 KB) in 0.04 seconds
```
Suppose we want to see all 10 keys that we read.  Recall that key-value pairs are stored as a nested
list.  So what we want is the first element of each element in the list.  We can use `lapply` to get
them:

```{r eval=FALSE, tidy=FALSE}
keys <- unlist(lapply(countySubsets, "[[", 1))
keys
```
```
 [1] "01013" "01031" "01059" "01077" "01095" "01103" "01121" "04001" "05019" "05037"
```

Finally, let's check that we have the FIPS code, state name, and county name information saved as 
attributes of the data frame.

```{r eval=FALSE, tidy=FALSE}
attributes(countySubsets[[1]][[2]])
```
```
$names
[1] "date"             "units"            "list"             "selling"

$row.names
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
[33] 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 
[65] 65 66

$state
[1] "AL"

$county
[1] "Butler"

$class
[1] "data.frame"
```

#### Map ####

```{r eval =FALSE, tidy=FALSE}
map3 <- expression({
  lapply(seq_along(map.keys), function(r) {
    line = strsplit(map.values[[r]], ",")[[1]]
    key <- line[1:3]
    value <- as.data.frame(rbind(line[c(-1, -2, -3)]), stringsAsFactors = FALSE)
    names(value) <- c("date", "units", "list", "selling")
    value$list <- as.numeric(value$list)
    value$selling <- as.numeric(value$selling)
    rhcollect(key, value)
  })
})

```

Note that we want to use the FIPS code as a unique identifier for the county, since counties in
different states can share a common name.  This time we've used a character vector of length 3
as the key.  It contains the unique FIPS code, the county name, and the state name.

#### Reduce ####

```{r eval=FALSE, tidy=FALSE}
reduce3 <- expression(
  pre = {
    oneCounty <- data.frame()
  },
  reduce = {
    oneCounty <- rbind(oneCounty, do.call(rbind, reduce.values))
  },
  post = {
    attr(oneCounty, "county") <- reduce.key[2]
    attr(oneCounty, "state") <- reduce.key[3]
    rhcollect(reduce.key[1], oneCounty)
  }
)
```

By removing the FIPS, county, and state columns from the data frame and storing them as
attributes, we've eliminated redundant information in each data frame. Working with massive 
data sets, we want our data to take up the least possible space on disk in order to save 
read/write time. Also we only keep the first element in `reduce.key` which is the `FIPS`
as the key in output key/value pairs.

