### Read and Divide by County ###
Our division method for the housing data will be to divide by county,
so there will 2883 subsets. Each subset will be a data.frame object with 4
column variables: `date`, `units`, `listing`, and `selling`.
`FIPS`, `state`, and `county` are not column variables because each has only one
value for each county; their values are added on the data.frame as
attributes.

The first step is to read each line of the file 'house.txt' into R. By
convention, `RHIPE` takes each line of a text file to be a key-value pair.
The line number is the key. The value is the data for the line, in our case
the 7 observations of the 7 variables of the data for one month and one county.
Also, when a line is read into R, each observation becomes of type character.

Each line is read as part of Map R code written by the user. The Map input
key-value pairs are the above line key-value pairs. Each line also has a Map
output key-value pair. The key identifies the county. `FIPS` could have been
enough to do this, but it is specified as a character vector with three
elements: the 3-vector values of `FIPS`, `state`, and `county`.
This is done so that
later all three can be added to the subset `data.frame`.
The Map output value for each line is the observations of `date`, `units`,
`listing`, and `selling` from the line.

The Map outputs are the inputs for the Reduce R code written by the user.
Reduce assembles these into groups by key, which means by  county. It then
creates the subset data.frame object for each county. Each row is the value
of one Reduce input key-value pair: observations of `date`, `units`, 
`listing`, and `selling`. `FIPS`, `state`, and `county` are added to the
data.frame as attributes. Finally, Reduce writes
each subset data.frame object to a directory in the HDFS specified by the user.
The subsets are written as Reduce output key-value pairs.
The output keys are the above 3-vectors. The output values are the county
data.frames.

#### Master and Commander: rhwatch() ####

We begin with the `RHIPE` R function `rhwatch()` that runs your R code
specifying Map and Reduce operations, allows you to specify input and
output files, and manages key-value pairs for you.

The code for the county division is
```{r eval=FALSE, tidy=FALSE}
mr3 <- rhwatch(
  map      = map3,
  reduce   = reduce3,
  input    = rhfmt("/myloginname/housing/housing.txt", type = "text"),
  output   = rhfmt("/myloginname/housing/byCounty", type = "sequence"),
  readback = FALSE,
  mapred   = list(
    mapred.reduce.tasks = 10
  )
)
```

Arguments `map` and `reduce` take your Map and Reduce R code.
`input` specifies the input text file in the HDFS that we put there earlier
using `rhput()`. `output` specifies the directory where the final outputs of
the Reduce operation are written. In our division by county here,
the Reduce outputs are the 2,883 county data.frame R objects.
They are placed in the output directory as key-value pairs,
each pair consisting of a county key it data.frame. `readback = FALSE` 
tells `RHIPE` not to write the Reduce output
to the global environment of your R session on the R session server.
Please see the detailed R documentation about `mapred.reduce.tasks`,
and about other arguments for `rhwatch()` not used above.

After the job completes successfully, the subsets by county has been saved on
HDFS. If we want to read all subsets back to R global environment of R session,
we could specify the `readback` to be `TRUE` in `rhwatch()`. However sometimes
we just want to read back very small amount of subsets from HDFS into our 
interactive R session just to check if everything is OK for the division we did.
Then we should use `rhread()` to read back subsets from HDFS. Also we should use 
the `max` argument to `rhread`, which specifies how many key-value pairs to read. 
The default value is -1, which means read in all key-value pairs. Here we only
read back 10 subsets.

```{r eval=FALSE, tidy=FALSE}
countySubsets <- rhread("/myloginname/housing/byCounty", max = 10)
```
```
Read 10 objects(31.39 KB) in 0.04 seconds
```
Suppose we want to see all 10 keys that we read.  Recall that key-value pairs are stored as a nested
list. In other words, `countySubsets` is a list with length 10. Each element of `countySubsets` is 
also a list with two elements. The first element is the key, which we know is the FIPS information for 
the corresponding county subset. The second element is the value, which is the data.frame for the county.
If we want to see all the keys of these 10 key-value pairs, we can use `lapply` to get them:

```{r eval=FALSE, tidy=FALSE}
keys <- unlist(lapply(countySubsets, "[[", 1))
keys
```
```
 [1] "01013" "01031" "01059" "01077" "01095" "01103" "01121" "04001" "05019" "05037"
```

`lapply` here can grab all the first elements of each element of `countySubsets` and save as a list.

Finally, let's check that we have the FIPS code, state name, and county name information saved as 
attributes of the data.frame. Recall that the second element of each element of `countySubsets` is
the data.frame for the corresponding county. Here let's look at the data.frame for the first subset.

```{r eval=FALSE, tidy=FALSE}
attributes(countySubsets[[1]][[2]])
```
```
$names
[1] "date"             "units"            "list"             "selling"

$row.names
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
[33] 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 
[65] 65 66

$state
[1] "AL"

$FIPS
[1] "01013"

$county
[1] "Butler"

$class
[1] "data.frame"
```

#### Map ####

```{r eval =FALSE, tidy=FALSE}
map3 <- expression({
  lapply(seq_along(map.keys), function(r) {
    line = strsplit(map.values[[r]], ",")[[1]]
    outputkey <- line[1:3]
    outputvalue <- data.frame(
      date = as.numeric(line[4]),
      units =  as.numeric(line[5]),
      list = as.numeric(line[6]),
      selling = as.numeric(line[7]),
      stringsAsFactors = FALSE
    )
  )
  rhcollect(outputkey, outputvalue)
  })
})
```

This code is really a `for loop`, but is done by `lapply()` because it is in
general faster. But we could have used `for r in 1:length(map.keys)`.
The loop proceeds through the input keys, which are the line numbers, as
specified by the first argument of `lapply`. The R `list` object `map.keys`
contains them; it is created by `rhwatch()`.  The
second argument of the above `lapply` defines the Map function with the
argument `r`, an index for the Map keys that goes from 1 to `length(map.keys)`.

`map.values` is also a `list` object created by `rhwatch()`.
`map.values[[r]]` is the value for key `map.keys[[r]]`.
The result of `line` in the `lapply` function is the input values, a
string.  The function `strsplit()` takes those values into the individual
observations of the text line, and creates a `list` of length one whose
element is a vector of length 7 that becomes `line`. `outputkey` is the FIPS
observation for the file line. `outputvalue` is a data.frame with one row and 6
columns of the values of variables for the text line that omits the state.

The RHIPE function `rhcollect()` forms a key-value for each line.

#### Reduce ####

```{r eval=FALSE, tidy=FALSE}
reduce3 <- expression(
  pre = {
    oneCounty <- data.frame()
  },
  reduce = {
    oneCounty <- rbind(oneCounty, do.call(rbind, reduce.values))
  },
  post = {
    attr(oneCounty, "FIPS") <- reduce.key[1]
    attr(oneCounty, "county") <- reduce.key[2]
    attr(oneCounty, "state") <- reduce.key[3]
    rhcollect(reduce.key[1], oneCounty)
  }
)
```

`reduce.values` is a `list` object. Each element is the Reduce input values for
one Reduce input key.

Reduce groups the Map output key-value pairs are grouped by output key,
the FIPS.  The current group's key is available in the object `reduce.key`, and all values associated with that key
are elements of the list object `reduce.values`. Recall that the `reduce.key` will be a character vector 
with length three, and they are FIPS, county name, and state name in this order. The reduce expression 
has three parts: `pre`, which is executed once first; `reduce`, which is executed repeatedly until all 
intermediate values associated with the current key have been processed; and `post`, which is executed
once at the end.  

In the reduce expression above, our goal is to combine all observations associated with one particular
county into a single data.frame.  In `pre`, we initialize an empty data frame, `oneCounty`.  In `reduce`, 
we use `rbind`
to combine all observations associated with one particular county.  In `post`, we add three attribute to the
data.frame containing the FIPS information, county name, and state name and emit the final key-value
pair.  The key is the first element of `reduce.key`, which is the FIPS, and the value is the data.frame 
with all observations belonging to that county with three attributes we created.
These final key-value pairs are written to HDFS, and will persist for subsequent analyses.

By removing the FIPS, county, and state columns from the data.frame and storing them as
attributes, we've eliminated redundant information in each data frame. Working with massive 
data sets, we want our data to take up the least possible space on disk in order to save 
read/write time. Also we only keep the first element in `reduce.key` which is the `FIPS`
as the key in output key/value pairs.

