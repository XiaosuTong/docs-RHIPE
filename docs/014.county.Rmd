### Read and Divide by County ###
Our division method for the housing data will be to divide by county,
so there will 2883 subsets. Each subset will be a `data.frame` object with 4
column variables: `date`, `units`, `listing`, and `selling`.
`FIPS`, `state`, and `county` are not column variables because each has only one
value for each county; their values are added on the `data.frame` as
attributes.

The first step is to read each line of the file 'house.txt' into R. By
convention, `RHIPE` takes each line of a text file to be a key-value pair.
The line number is the key. The value is the data for the line, in our case
the 7 observations of the 7 variables of the data for one month and one county.
Also, when a line is read into R, each observation becomes of type character.

Each line is read as part of Map R code written by the user. The Map input
key-value pairs are the above line key-value pairs. Each line also has a Map
output key-value pair. The key identifies the county. `FIPS` could have been
enough to do this, but it is specified as a character vector with three
elements: the values of `FIPS`, `state`, and `county`. This is done so that
later all three can be added to the subset `data.frame`.
The Map output value for each line is the observations of `date`, `units`,
`listing`, and `selling` from the line.

The Map outputs are the inputs for the Reduce R code written by the user.
Reduce assembles these into groups by key, which means by  county. It then
creates the subset `data.frame' object for each county. Each row is the value
of one Reduce input key-value pair: observations of `date`, `units`, 
`listing`, and `selling`. `FIPS`, `state`,
and `county` are added to the data.frame as attributes. Finall, Reduce writes
each subset `data.frame` object to a directory in the HDFS specfied by the user.
The subsets are written as key-value pairs where the keys are the observations
of `FIPS` and the values are the county `data.frames`.

#### Master and Commander: rhwatch() ####

We begin with the `RHIPE` R function `rhwatch()` that runs your R code
specifying Map and Reduce operations, allows you to certain specify input and
output files, and as we will see, manages key-value pairs for you.

The code for the county division is
```{r eval=FALSE, tidy=FALSE}
mr3 <- rhwatch(
  map      = map3,
  reduce   = reduce3,
  input    = rhfmt("/myloginnamehousing/housing.txt", type = "text"),
  output   = rhfmt("/myloginname/housing/housing/byCounty", type = "sequence"),
  readback = FALSE,
  mapred   = list(
    mapred.reduce.tasks = 10
  )
)
```

Arguments `map` and `reduce` take your Map and Reduce R code.
`input` specifies the input text file in the HDFS that we put there earlier
using `rhput()`. `output` specifies the directory where the final outputs of
the Reduce operation are written. In our division by county here,
the Reduce outputs are the 49 county `data.frame` R objects.
They are placed
there as key-value pairs, each pair consisting of a county key it
`data.frame`. `readback = FALSE` tells `RHIPE` not to write the Reduce output
to the global environment of your R session on the R session server.
Please see the detailed R documentation about `mapred.reduce.tasks`,
and about other arguments for `rhwatch` not used above.

After the job completes successfully, we'll read the results from HDFS into our interactive R 
session as we did before.  This time, let's use the `max` argument to `rhread`, which specifies 
how many key-value pairs to read. The default value is -1, which means read in all key-value pairs.

```{r eval=FALSE, tidy=FALSE}
countySubsets <- rhread("/ln/tongx/housing/byCounty", max = 10)
```

Read 10 objects(31.39 KB) in 0.04 seconds
```
Suppose we want to see all 10 keys that we read.  Recall that key-value pairs are stored as a nested
list.  So what we want is the first element of each element in the list.  We can use `lapply` to get
them:

```{r eval=FALSE, tidy=FALSE}
keys <- unlist(lapply(countySubsets, "[[", 1))
keys
```
```
 [1] "01013" "01031" "01059" "01077" "01095" "01103" "01121" "04001" "05019" "05037"
```

Finally, let's check that we have the FIPS code, state name, and county name information saved as 
attributes of the data frame.

```{r eval=FALSE, tidy=FALSE}
attributes(countySubsets[[1]][[2]])
```
```
$names
[1] "date"             "units"            "list"             "selling"

$row.names
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
[33] 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 
[65] 65 66

$state
[1] "AL"

$county
[1] "Butler"

$class
[1] "data.frame"
```

#### Map ####

```{r eval =FALSE, tidy=FALSE}
map3 <- expression({
  lapply(seq_along(map.keys), function(r) {
    line = strsplit(map.values[[r]], ",")[[1]]
    outputkey <- line[1:3]
    outputvalue <- data.frame(
	date = as.numeric(line[4]),
	units =  as.numeric(line[5]),
	list = as.numeric(line[6]),
        selling = as.numeric(line[7]),
	stringsAsFactors = FALSE)
	)
    rhcollect(outputkey, outputvalue)
  })
})

```

This code is really a `for loop`, but is done by `lapply()` because it is in
general faster. But we could have used `for r in 1:length(map.keys)`.
The loop proceeds throught the input keys, which are the line numbers, as
specified by the first argument of `lapply`. The R `list` object `map.keys`
contains them; it is created by `rhwatch()`.  The
second argument of the above `lapply` defines the Map function with the
argument `r`, an index for the Map keys that goes from 1 to `length(map.keys)`.

`map.values` is also a `list` object created by `rhwatch()`.
`map.values[[r]]` is the value for key `map.keys[[r]]`.
The result of `line` in the `lapply` function is the input values, a
string.  The function `strsplit()` takes those values into the individual
observations of the text line, and creates a `list` of length one whose
element is a vector of length 7 that becomes `line`. `key` is the state
observation for the file line. `value` is a `dataframe` with one row and 6
columns of the values of variables for the text line that omits the state.

The RHIPE function `rhcollect()` forms a key-value for each line.

#### Reduce ####

```{r eval=FALSE, tidy=FALSE}
reduce3 <- expression(
  pre = {
    oneCounty <- data.frame()
  },
  reduce = {
    oneCounty <- rbind(oneCounty, do.call(rbind, reduce.values))
  },
  post = {
    attr(oneCounty, "county") <- reduce.key[2]
    attr(oneCounty, "state") <- reduce.key[3]
    rhcollect(reduce.key[1], oneCounty)
  }
)
```

By removing the FIPS, county, and state columns from the data frame and storing them as
attributes, we've eliminated redundant information in each data frame. Working with massive 
data sets, we want our data to take up the least possible space on disk in order to save 
read/write time. Also we only keep the first element in `reduce.key` which is the `FIPS`
as the key in output key/value pairs.

